<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"node_modules_keef_index.js.html":{"id":"node_modules_keef_index.js.html","title":"Source: node_modules/keef/index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: node_modules/keef/index.js /*jshint node:true, laxcomma: true, smarttabs: true*/ 'use strict'; /** The conf package reads configurations options in an overriding fashion from a number of sources. In order of importance: 1. System level overrides 2. Command line arguments 3. Environment variables 4. A configuration file(s) 5. System specified defaults ### Overrides Overrides can not be overriden or changed at any point in time. The are defined in `conf/lib/overrides.js` and should be reserved for static run time properties. Conf serves as a central place to get that information. For example, the full path to the packages directory is resolved at run time and loaded in to the conf loader. It won't / can't change during run time, but may change in the future. By getting the information from conf, application logic does not need to change between restarts or releases. If overrides need to be change or added the `overrides.js` file must be changed ### Command Line Arguments Command line arguments are the highest level of maliable values. The can be used to set specific and nested values in the configuration JSON document but using a `:` spearator between keys. For example, using the flag: `--foo:bar=1`, would create an object like ```js { &quot;foo&quot;:{ &quot;bar&quot;: 1 } } ``` ### Environment Variables Environment variables work much the same as command line arguments. However, most bash implenetations don't read `:`'s very well, so the double underscore ( `__` ) is used in its place `foo__bar=1` npm start ```js { &quot;foo&quot;:{ &quot;bar&quot;: 1 } } ``` ### Conf Options The `conf` option can be set to read specific configuration from a file(s). The value should be a full path. If the path points to a directory, the conf loader will read all json files, sort them and load their values in an overriding order. Sorting is done in a descending, lexigraphical order. ```sh └── conf ├── 20-keef.json ├── 10-keef.json └── 30-keef.json ``` Given the above directory of conf files, the server can be configured by pointing the `conf` arguments at the directory ```sh node server --conf=$HOME/conf ``` The configruation would be read in the following priority ``` 10-keef.json &lt; 20-keef.json &lt; 30-keef.json``` where 20 overrides 10, and 30 overrides 20. ### Static File Defaults To Simplify configuration for deployments, `keef` will look for configuration files in fixed locations eliminating the need for run time configuration. File Locations are as follows: 1. a file in the rooot of your project with the name `&lt;package.name&gt;`.`NODE_ENV`.`json` For example, if the `name` attribute in your package.json is `foobar`, and the environment var `NODE_ENV` is set as `production`, the file look up is `foobar.production.json`. If `NODE_ENV` is not set, it would be `foobar.development.json` 2. A json file named after your project name in the root of your project - `foobar.json` 3. A json file named after your project in a `.config` directory in the current users home directory - `.config/foobar.json` 4. A json file named after your project in the `/etc` directory - `/etc/foobar.json ### ETCD2 Clusters For distributed deployments, An etcd2 cluster may be used for configuration purposes. To enable `etcd2` configuration loading, 2 environment variables should be set: 1. `etcd__hosts` - A comma separated list of `host`:`port` addresses - `etcd1.domain.com:4001,etcd2.domain.com:4001`. 2. `etcd__namespace` - a keyspace to keep data separate from everything else. Any configuration that is stored as object, we be translated into `etcd` directories automatically ```js keef.set('a:b:c', 1) // Object data { &quot;a&quot;: { &quot;b&quot;: { &quot;c&quot;: 1 } } } // etc data /a/b/c 1 ``` ### System defaults defaults are what they sound like. Sane defaults for values that are needed to get the application running. They are located in the {@link module:keef/lib/defaults|Defaults} module and are used only as fallback values. ### Option Shorthands Top level options can be aliased. Short hand aliases can be found and defined in the {@link module:keef/lib/shorthands|Shorthands} module of `keef` Flag | Shorthand | Description -----|:---------:|:------------ PORT | p | Specifies the port the server will bind to logger | l | specify the type(s) of logging transports for the server to use the following invocations are treated the same ```sh node server --PORT=3001 --logger=stdout --logger=file ``` ```sh PORT=3001 logger=stdout nodeserver -l file ``` ```sh node server -p 3001 -l stdout -l file ``` * @summary The configuration loader for keef, the spirit shop platform api.* * @module keef * @author Eric Satterwhite * @since 0.1.0 * @requires nconf * @requires path * @requires os * @requires debug * @requires fs * @requires keef/lib/shorthands * @requires keef/lib/defaults * @requires keef/lib/overrides */ var nconf = require( 'nconf' ) // flatiron nconf module , path = require( 'path' ) // node path module , util = require( 'util' ) // node path module , os = require( 'os' ) // node os module , fs = require( 'fs' ) // node fs module , Etcd = require('nconf-etcd2') , debug = require( 'debug' )('keef:conf') // debug function spoped to keef:conf , shorthands = require('./lib/shorthands') // quick argv shorthands mapping , defaults = require('./lib/defaults') // config defaults , overrides = require('./lib/overrides') // static system overrides that can't / shouldn't change , merge = require('mout/object/merge') , keefcheck = /^keef/ , apppaths = [ ] , defaultCfg = {} , modules , lookuppaths // look up paths to possible locations where config files may live , startup // referece to the conf object for start up options. Gets deleted at the end , configFile // the location to look for a user defined config file, or a directory , envFile , pkg , pkgname , pkgfile , etc_config , conf , cwd // the final configuration object to export ; cwd = process.cwd(); startup = nconf .argv() .env({separator:'__'}) .defaults( defaults ); try{ pkg = path.join(overrides.PROJECT_ROOT, 'package.json'); pkgname = require(pkg).name.trim(); } catch( e ){ debug('package error ', e.message); pkgname = 'default'; } pkgfile = pkgname +'.json' envFile = util.format('%s.%s.json', pkgname, startup.get('NODE_ENV') || 'development'); envFile = path.resolve( cwd, envFile); debug(&quot;package info: &quot;, pkgname, pkg) // order matters, otherwise this could be an object lookuppaths =[ ['nenv', envFile ] , ['project', path.normalize( path.join( overrides.PROJECT_ROOT, pkgfile ) )] , ['home',path.normalize( path.join(( process.env.USERPROFILE || process.env.HOME || overrides.PROJECT_ROOT ),'.config', pkgfile) ) ] , ['etc', path.normalize('/etc/' + pkgfile )] ]; configFile = path.resolve( startup.get( 'conf' ) || pkgfile ); overrides.CONFIG_PATH = configFile startup.remove('env'); startup.remove('argv'); startup.remove('defaults'); startup = null; debug('config file set to %s', configFile ); debug('project root set to %s', overrides.PROJECT_ROOT ); debug('package path set to %s', overrides.PACKAGE_PATH ); conf = nconf .overrides( overrides ) .argv( shorthands ) .env({separator:'__'}); // if the specified config file is actually a directory // start looking for json files and try to sort them if( fs.existsSync( configFile ) ){ if( fs.statSync( configFile ).isDirectory() ){ debug('detected config directorty') fs .readdirSync( configFile ) .filter( function( file ){ return (/\\.json$/).test( file ); }) .sort( function( file_a, file_b ){ return file_a &lt; file_b; }) .forEach( function( file ){ var filepath = path.normalize( path.join( configFile, file ) ); debug('loading config file `%s` %s', file, filepath); conf = conf.file( file, filepath ); }); } else{ conf = conf.file( 'conf', configFile ); } } lookuppaths.forEach(function( lp ){ debug('loading config file `%s`: %s', lp[0], lp[1]); conf = conf.file( lp[0], lp[1] ); }); apppaths = conf.get(pkgname + ':applications') || []; apppaths = Array.isArray( apppaths ) ? apppaths : [apppaths]; apppaths.push( cwd ); debug('setting config defaults'); debug(&quot;configuration modules %s&quot;, apppaths.join(', ')); apppaths.forEach(function( pconf ){ var config; try{ config = require( path.join( pconf, 'conf' ) ); defaultCfg = merge( defaultCfg, config ); debug('loaded package defaults from %s', pconf ); } catch( e ){ debug('unable to load %s configuration: %s', pconf, e.message ); } }); etc_config = conf.get('etcd') debug('etcd config: ', etc_config ) if( etc_config &amp;&amp; etc_config.hosts ){ var etc_hosts = toArray( typeof etc_config.hosts === 'string' ? etc_config.hosts.split(',') : etc_config.hosts ); debug('found etcd hosts:', etc_hosts) etc_config.hosts = etc_hosts; etc_hosts &amp;&amp; conf.use('etcd', etc_config ); } apppaths.pop(); defaultCfg = merge( defaultCfg, defaults ); conf .defaults(defaultCfg); module.exports = conf; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: index.js 'use strict'; /** * Distributed timers as a service * Exports a default server instance. If executed directly, the server will be started automoaticall and configured to auto rebalance on `SIGINT` and `SIGTERM` * @module skyring * @author Eric Satterwhite * @since 1.0.0 * @requires http * @requires debug * @requires keef * @requires skyring/lib/server **/ process.title = 'skyring'; process.chdir(__dirname); const http = require('http') , conf = require('keef') , Server = require('./lib/server') , debug = require('debug')('skyring') ; const server = new Server(); module.exports = server; if( require.main === module ){ server.load().listen(conf.get('PORT'),null, null, (err) =&gt; { if(err) return console.log(err) || process.exit(1) debug('server listening') }); } function onSignal() { server.close(()=&gt;{ debug('shutting down') process.statusCode = 0 }) } process.once('SIGINT', onSignal); process.once('SIGTERM', onSignal); × Search results Close "},"conf_index.js.html":{"id":"conf_index.js.html","title":"Source: conf/index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: conf/index.js 'use strict' /** * Configuration options for skyring. See {@link module:keef} on ways to pass configuration * @module skyring/conf * @author Eric Satterwhite * @since 1.0.0 **/ const os = require('os') const path = require('path') module.exports = { /** * @property {String|String[]} [seeds=127.0.0.1:3455,127.0.0.1:3456] A list of seed nodes to use for bootstrapping a ring cluster * @property {Object} channel * @property {String} [channel.host=127.0.0.1] hostname or ip addres for tchannel to listen on * @property {Number} [channel.port=3455] Port number for tchannel to bind to * @property {Number} [PORT=3000] The port number for the http API server to bind to * @property {Object} nats Nats queue specific configuration * @property {String|String[]} [nats.hosts=127.0.0.1:4222] host:port of instances of a nats cluster. One is usually enough. * @param {Object} [options.storage] Storage config options for level db * @param {String[]} [options.storage.backend=memdown] a requireable module name, or absolute path to a leveldb compatible backend * `leveldown` and `memdown` are installed by default * @param {String} options.storage.path A directory path to a leveldb instance. One will be created if it doesn't already exist. * If the backend is memdown, this is optional and randomly generated per timer instance **/ seeds: ['127.0.0.1:3455', '127.0.0.1:3456'] , storage: { backend: 'memdown' , path: null } , channel: { host:'127.0.0.1' , port: 3455 } , PORT: 3000 , nats: { hosts:'127.0.0.1:4222' } } × Search results Close "},"lib_json.js.html":{"id":"lib_json.js.html","title":"Source: lib/json.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/json.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true*/ 'use strict'; /** * JSON helpers * @module skyring/lib/json * @author Eric Satterwhite * @since 1.0.0 */ /** * Composite JSON ojbect * @typedef {Object} Result * @property {?Error} [error=null] An error if json parsing faile * @property {Object} value the result of Json parsing **/ /** * Wrpper around try/catch of JSON parsing * @method module:skyring/lib/json * @param {String} json A JSON string to parse * @return {module:skyring/lib/json~Result} **/ exports.parse = function parse(json) { if (!json) return {error: null, value: {}} try { return { error: null, value: JSON.parse(json) } } catch( e ) { return {error: e, value: null} } } × Search results Close "},"lib_nats.js.html":{"id":"lib_nats.js.html","title":"Source: lib/nats.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/nats.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true*/ 'use strict'; /** * Small wrapper around nats for quickly connecting / disconnecting * @module skyring/lib/nats * @author Eric Satterwhite * @since 1.0.0 * @requires url * @requires nats * @requires keef * @requires debug * @example const nats= require('skyring/lib/nats') const client = nats.createClient() client.publish('foobar', JSON.stringify({'foo':'bar'}), () =&gt; { nats.quit() }) */ const url = require('url') , util = require('util') , nats = require('nats') , config = require('keef') , debug = require('debug')('skyring:nats') , nats_hosts = config.get('nats:hosts') , csv_exp = /\\s?,\\s?/g; /** * Creates a new nats client * @method module:skyring/lib/nats#createClient * @param {Object} [options] nats client configuration * @param {String} [options.hosts=localhost:4222] a comma separated list of addresses of nats hosts to connect to * @return {NatsClient} A nats client instance * @example nats.createClient({ hosts:'nats-1.domain.com:4222,nats-2.domain.com:4223,localhost:4222' }) **/ exports.createClient = createClient Object.defineProperty(exports, 'client', { get: function() { return client || createClient() } }) function createClient(options) { const hosts = (options &amp;&amp; options.hosts) || nats_hosts; const servers = Array.isArray(hosts) ? hosts : parse(hosts); const opts = Object.assign({}, options, {servers}); debug('creating nats client', opts); const client = nats.connect(opts); client.on('error', (err) =&gt; { console.error('nats error', err); }); client.on('connect', () =&gt; { debug('nats connection successful'); }); client.on('end', () =&gt; { debug('nats connection closed'); client.removeAllListeners(); }); client.on('ready', () =&gt; { debug('nats connection ready'); }); client.on('reconnecting', () =&gt; { debug('nats client reconnecting'); }) client.quit = (cb) =&gt; { debug('closing nats', client.info.server_id) client.close(); client.once('disconnect', cb) } return client; } function parse(str) { if (typeof str !== 'string') { throw new TypeError('nats hosts must be a string'); } const items = str.split(csv_exp); return items.map(parseItem); } function parseItem(str) { return str.indexOf('nats://') === 0 ? str : `nats://${str}` } × Search results Close "},"lib_server_index.js.html":{"id":"lib_server_index.js.html","title":"Source: lib/server/index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/server/index.js /*jshint laxcomma: true, smarttabs: true, node: true, esnext: true*/ 'use strict'; /** * Primary server instance for a skyring app. * @module skyring/lib/server * @requires http * @requires debug * @requires skyring/lib/server/mock * @requires skyring/lib/server/node * @requires skyring/lib/server/router * @requires skyring/lib/timer */ const http = require('http') , Debug = require('debug') , mock = require('./mock') , Node = require('./node') , Router = require('./router') , Timer = require('../timer') , debug = Debug('skyring:server') ; /** * @constructor * @extends http.Server * @alias module:skyring/lib/server * @author Eric Satterwhite * @since 1.0.0 * @param {Object} [options] * @param {module:skyring/lib/server/node} [options.node] A customer node instance * @param {String} [optiopns.node.host] host name for the node to listen on - 127.0.0.1 must be used for localhost ( not 0.0.0.0 ) * @param {Number} [options.node.port] Port number for the node to listen on in the ring * @param {String} [options.node.app=timers] name of the active ring to join * @param {Object} [options.nats] * @param {String[]} [options.nats.servers] An array of nats `host:port` addresses to connect to * @example // Use only configuration values var server = new Server().load().listen(5000) * @example var server = new Server({ node :{ host: 172.17.0.9 , port: 8456 , app: 'payback' } , nats: { servers: ['nats1.domain.com:4222', 'nats2.domain.com:4222'] } }) server.load().listen(5000) * @example // Use a custom node instance var node = new Node({ host: 172.17.0.9 , port: 8456 , app: 'payback' }) var server = new Server({ node }) server.load().listen(5000) */ class Server extends http.Server { constructor( opts={} ){ super((req, res) =&gt; { this._router.handle(req, res) }); this.closed = false; this.options = Object.assign({}, { seeds: null , nats: null , storage: null }, opts) this.loaded = false; if( opts.node ){ this._node = opts.node instanceof Node ? opts.node : new Node( opts.node.host, opts.node.port, opts.node.name, opts.node.app ); } else { this._node = new Node() } this._group = this._node.name this._timers = new Timer({ nats: this.options.nats, storage: this.options.storage }); this._router = new Router(this._node, this._timers); this._node.on('ringchange', (evt) =&gt; { this._timers.rebalance(evt, this._node, (data) =&gt; { this.proxy(data); }); }); this._node.on('bootstrap', (seeds) =&gt; { this.emit('bootstrap', seeds); }) } /** * loads application routes if not already loaded * @method module:skyring/lib/server#load * @return {module:skyring/lib/server} **/ load() { if( this.loaded ) return this; const routes = require('./api') Object.keys(routes) .forEach((name) =&gt; { const item = routes[name]; const route = this._router.route( item.path , item.method , item.handler ); item.middleware &amp;&amp; route.before( item.middleware ); }) return this; } /** * Joins the node to the configured ring and starts the http server * @method module:skyring/lib/server#listen * @param {Number} port Port number to listen on * @param {String} [host=localhost] host or ip address to listen on * @param {Number} [backlog] * @param {Function} [callback] Callback function to call when the server is running * @return {module:skyring/lib/server} **/ listen(port, host, backlog, callback) { debug('seed nodes', this.options.seeds); this._node.join(this.options.seeds, (err) =&gt; { if (err) { console.error(err) return callback &amp;&amp; callback(err) } this._node.handle(( req, res ) =&gt; { this._router.handle( req, res ); }) this._timers.watch(`skyring:${this._group}`, (err, data) =&gt; { this.proxy(data) }); super.listen(port, host, backlog, callback) }) return this; } proxy(data) { debug('fabricating request', data.id) const opts = { url: '/timer' , method: 'POST' , headers: { &quot;x-timer-id&quot;: data.id } , payload: JSON.stringify(data) } const res = new mock.Response(); const req = new mock.Request( opts ); this._router.handle( req, res ); } /** * Removes a server from the ring, closes the http server and redistributes * any pending timers * @method module:skyring/lib/server#close * @param {Function} callback A callback to be called when the server is completely shut down **/ close( cb ){ if(this.closed) return cb &amp;&amp; setImmediate(cb); super.close(() =&gt; { this._node.close(() =&gt; { this._timers.shutdown(() =&gt; { debug('closing server') this.closed = true cb &amp;&amp; cb() }) }) }) } } module.exports = Server; module.exports.Router = Router; × Search results Close "},"lib_server_mock.js.html":{"id":"lib_server_mock.js.html","title":"Source: lib/server/mock.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/server/mock.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true*/ 'use strict'; /** * Mock http request / response object for use when proxing requests through TChannel * @module skyring/lib/server/mock * @author Eric satterwhite * @since 1.0.0 * @requires stream * @requires events * @requires url * @requires util * @requires http */ const stream = require('stream') , EventEmitter = require('events').EventEmitter , url = require('url') , util = require('util') , http = require('http') ; exports.Request = class Request extends stream.Readable { constructor ( options ){ super(); this.body = ''; this.httpVersion = '1.1'; this.payload = options.payload this.url = options.url || '/'; this.query = url.parse(this.url, true).query; this.headers = options.headers || {}; this.method = options.method; this._headerNames = {}; this._removedHeader = {}; this.setHeader('transfer-encoding', 'chunked'); } setHeader(name, value) { this.headers[name.toLowerCase()] = value; } getHeader(name){ return this.headers[name]; } _read(){ if(this.payload){ this.push(this.payload) this.payload = null return; } this.push(null); } } exports.Response = class Response extends EventEmitter { constructor(callback){ super(); this.buffer = []; this.statusCode = 200; this._headers = {}; this.on('data', function (chunk) { this.buffer.push(chunk); }); this.on('pipe', function (src) { var buffer = this.buffer; src.on('data', function (chunk) { buffer.push(chunk); }) }); this.on('close', function () {}); if (callback) { var self = this; var cleanup = function () { self.removeListener('error', cleanup) self.removeListener('response', cleanup) callback.apply(this, arguments) } this.once('error', cleanup); this.once('response', cleanup); } // necessary for mocking a real request. this._headerNames = {}; this._removedHeader = {}; } writeHead(){ var that = this; this.statusCode = statusCode; Object.keys(headers || {}).forEach(function (k) { that.setHeader(k, headers[k]); }); } setHeader(name, value, clobber){ if (http.ServerResponse) { var ret = http.ServerResponse.prototype.setHeader.call(this, name, value, clobber); this.headers = this._headers; return ret; } else if (clobber || !this.headers.hasOwnProperty(name)) { this.headers[name] = value; } else { this.headers[name] += ',' + value; } } getHeader(){ if (http.ServerResponse) { return http.ServerResponse.prototype.getHeader.call(this, name); } else { return this.headers[name]; } } end(str){ if (this.finished) { return; } if (str) { this.buffer.push(str); } var body = this._buildBody(); this.emit('close'); this.emit('finish'); this.emit('end', null, { // deprecate me statusCode: this.statusCode, body: body, headers: this._headers }); this.emit('response', null, { statusCode: this.statusCode, body: body, headers: this._headers }); this.finished = true // Cleanup any listeners that are 'hanging' around. this.removeAllListeners(); } _buildBody(){ if (this.buffer.length === 1) { return this.buffer[0]; } var isBuffers = true; for (var i = 0; i &lt; this.buffer.length; i++) { if (!Buffer.isBuffer(this.buffer[i])) { isBuffers = false; } } if (!isBuffers) { return this.buffer.join(''); } return Buffer.concat(this.buffer); } } × Search results Close "},"lib_server_node.js.html":{"id":"lib_server_node.js.html","title":"Source: lib/server/node.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/server/node.js /*jshint laxcomma: true, smarttabs: true, node: true, esnext: true*/ /** * Represents a participant in the Hashring * @module skyring/lib/server/node * @author Eric Satterwhite * @since 1.0.0 * @requires events * @requires dns * @requires ringpop * @requires tchannel * @requires debug * @requires keef */ const EventEmitter = require('events').EventEmitter , dns = require('dns') , Ringpop = require('ringpop') , TChannel = require('tchannel') , debug = require('debug')('skyring:ring') , conf = require('keef') , host = conf.get('channel:host') , port = ~~conf.get('channel:port') ; let ring_seeds = conf.get('seeds'); ring_seeds = !Array.isArray(ring_seeds) ? ring_seeds.split(',') : ring_seeds; function resolve( tasks, cb ){ const results = []; ;(function next(){ if(!tasks.length) return cb(null, results); const task = tasks.shift(); let [h, p] = task.split(':'); dns.lookup(h, (err, addr) =&gt; { if (err) return cb(err) results.push(`${addr}${p ? ':' + p : ''}`); next() }) })() } /** * @constructor * @alias module:skyring/lib/server/node * @param {String} [host] host name for the node to listen on - 127.0.0.1 must be used for localhost ( not 0.0.0.0) * @param {Number} [port] Port number for the node to listen on in the ring * @param {String} [name='ringpop'] name of the active ring to join * @param {String} [app=timers] app name of the active ring */ class Node extends EventEmitter { constructor(h = host, p = port, name = 'ringpop', app = 'timers' ) { super() this._port = p; this._host = host; this._name = name; this._app = app; this._tchannel = new TChannel(); this._ring = null } /** * Does the work of configuring tchannel and joining itself into a ringpop ring * @method module:skyring/lib/server/node#join * @param {String[]} [seeds] An array of node addresses to use as boot strapping nodes * @param {Function} callback Function to call when the node has completed the bootstrap process * @example node.join(['node-1:5555', '172.10.0.4:4563'], (err) =&gt; { if (err) throw err }) **/ join(seed_arr, cb){ const nodes = seed_arr || ring_seeds if(!Array.isArray(nodes)) { const err = new TypeError('seeds must be and array') return cb(err) } let addrs = [this._host].concat(nodes); resolve(addrs, (err, seeds) =&gt; { if( err ) return cb( err ); const host = seeds.shift(); this._ring = new Ringpop({ app: this._app , hostPort:`${host}:${this._port}` , channel: this._tchannel.makeSubChannel({ serviceName: this._name , trace:false }) }); this._ring.setupChannel(); this._ring.on('ringChanged', ( evt ) =&gt; { const added = evt.added; if(!added.length) return; if(added.length === 1 &amp;&amp; added.indexOf(`${host}:${this._port}`) !== -1) return; debug('node added', added) this.emit('ringchange', evt); }) this._tchannel.listen( this._port, host, (er)=&gt; { if(er) return cb(er) debug('tchannel listening on ', host, this._port); this._ring.bootstrap(seeds, ( er ) =&gt; { if( er ) return cb(er); debug( 'ring bootstraped', seeds); this.emit('bootstrap', seeds) cb(null); }); }); }) } /** * Removes itself from the active ring and destroys existing connections * @method module:skyring/lib/server/node#leave * @param {Function} callback Callback function to call when the eviction process is complete **/ leave(cb){ this._ring.selfEvict((err)=&gt;{ if( err ) return cb( err ); this._tchannel.drain('leaving ring', () =&gt; { this._ring.destroy(); }) cb(); }) } /** * Adds a request handler to the active ringpop instance * @method module:skyring/lib/server/node#handle * @param {Function} handler A request handler for incoming requests from the ring **/ handle(cb) { return this._ring.on('request', cb) } /** * Determines if this instance is responsible for a specific key. * proxies the request if it is not * @method module:skyring/lib/server/node#handleOrProxy * @param {String} Key The key to use to do a node lookup in the ring * @param {http.IncomingMessage} req an http request object * @param {http.ServerResponse} res an http response object * @example const handle = node.handleOrProxy('foobar', req, res) if (!handle) return; // deal with request * @return {Boolean} **/ handleOrProxy(key, req, res) { return this._ring.handleOrProxy(key, req, res); } /** * Determines if this node is responsible for a specific key * @method module:skyring/lib/server/node#owns * @param {String} key The key to use * @return {Boolean} **/ owns( key ){ return this._ring.lookup( key ) == this._ring.whoami() } /** * Lookup the address of the server responsible for a given key * @method module:skyring/lib/server/node#lookup * @param {String} key The key to look up * @return {String} A server address **/ lookup( key ) { return this._ring.lookup(key); } /** * Removes itself from the ring and closes and connections * @method module:skyring/lib/server/node#close * @param {Function} A callback function to call when the ring is closed **/ close( cb ) { debug('node close') this._ring.selfEvict(() =&gt; { debug('draining tchannel') this._tchannel.drain('leaving', () =&gt; { debug('destroying ring'); this._ring.once('destroyed',()=&gt;{ setTimeout(cb, 100) }); this._ring.destroy(); }) }) } } Object.defineProperty(Node.prototype, 'name', { get: function() { return this._app; } }) module.exports = Node; × Search results Close "},"lib_server_request.js.html":{"id":"lib_server_request.js.html","title":"Source: lib/server/request.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/server/request.js 'use strict'; /** * Simple wrapper around the http request object to avoid deopts * @module skyring/lib/server/request * @author Eric Satterwhite * @since 1.0.0 * @requires url */ const {Url} = require('url') , cache = new WeakMap() , qs = require('querystring') , pathexp = /^(\\/\\/?(?!\\/)[^\\?#\\s]*)(\\?[^#\\s]*)?$/ ; function Request( req ) { const parsed = parseurl(req); this._body = false; this.body = null; if ( parsed ) { this.query = parsed.query; this.path = parsed.pathname; } else { this.query = Object.create(null); this.path = null; } this.headers = req.headers; } Request.prototype.get = function get( key ) { const _key = key.toLowerCae(); const headers = this.req.headers || {}; switch (_key) { case 'referrer': case 'referer': return headers.referrer || headers.referer; default: return headers[_key]; } }; function parseurl( req ) { const url = req.url; if (!url) return url; if ( cache.has(req) ) return cache.get(req); const parsed = fastparse(url); cache.set(req, parsed); return parsed; } function fastparse( str ) { const simple = typeof str === 'string' &amp;&amp; pathexp.exec( str ); if ( simple ) { const pathname = simple[1]; const search = simple[2] || null; const url = new Url(); url.path = str; url.href = str; url.pathname = pathname; url.search = search; url.query = url.search ? qs.parse( search.substr( 1 ) ) : Object.create(null); return url; } return parseurl( str, true ); }; module.exports = Request; × Search results Close "},"lib_server_response.js.html":{"id":"lib_server_response.js.html","title":"Source: lib/server/response.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/server/response.js 'use strict' /** * Simple wrapper around the http response object to avoid deopts * @module skyring/lib/server/response * @author Eric Satterwhite * @since 1.0.0 * @requires debug */ const debug = require('debug')('skyring:error') function Response( res ) { this.res = res this.body = null }; Response.prototype.error = function error( err, msg ) { if(typeof err === 'number') { return this.status(err).json({ message: msg }) } err.statusCode = err.statusCode || err.code; if( !err.statusCode ) { err.statusCode = 500; err.message = 'Internal Server Error'; } this.status( err.statusCode ); debug(err) this.res.setHeader('x-skyring-reason', err.message) return this.end() } Response.prototype.get = function get( key ) { return this.res.getHeader(key); }; Response.prototype.json = function json( body ) { this.res.setHeader('Content-Type', 'application/json'); this.res.end(JSON.stringify(body)); return this; }; Response.prototype.set = function set( key, val ) { var value = Array.isArray(val) ? val.map(String) : typeof val === 'string' ? val : String(val); this.res.setHeader(key, value); return this; }; Response.prototype.status = function status( code ) { this.res.statusCode = code; return this; }; Response.prototype.send = function send( str ) { this.res.write( str ); return this; } Response.prototype.end = function end( str ) { this.res.end(str); return this; }; module.exports = Response; × Search results Close "},"lib_server_route.js.html":{"id":"lib_server_route.js.html","title":"Source: lib/server/route.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/server/route.js 'use strict'; /** * represents the middleware stack for a url / method combination * @module skyring/lib/server/route * @author Eric Satterwhite * @since 1.0.0 * @requires path-to-regexp */ const pathToRegExp = require('path-to-regexp'); /** * * @constructor * @alias module:skyring/lib/server/route * @param {String} path the url pattern to match * @param {String} method The http method to respect * @example var rte = new Route('/foo/:id', 'POST') rte.use((req, res, node, next) =&gt; { if(req.method === 'DELETE') { const err = new Error('Not Implemented') err.statusCode = 501 next(err) } }) **/ function Route(path, method) { this.path = path; this.method = method; this._keys = []; this.stack = []; this.regexp = pathToRegExp(path, this._keys); this.keys = new Array(this._keys.length); this.params = Object.create(null); for( var idx = 0; idx &lt; this._keys.length; idx++ ) { this.keys[ idx ] = this._keys[ idx ].name; this.params[ this._keys[ idx ].name ] = undefined; } } /** * Adds a middleware function to the end of the internal route stack * @method module:skyring/lib/server/route#use * @param {module:skyring/lib/server/route~Middleware} fn a the middelware function to add **/ Route.prototype.use = function use( fn ) { if( Array.isArray( fn ) ) { for(var idx = 0; idx &lt; fn.length; idx++) { this.stack.push( fn[idx] ); } } else { this.stack.push( fn ); } return this; }; /** * Adds a middleware function to the beginning of the internal route stack * @method module:skyring/lib/server/route#before * @param {module:skyring/lib/server/route~Middleware} fn a the middelware function to add **/ Route.prototype.before = function before( fn ) { if( Array.isArray( fn ) ) { this.stack.unshift( ...fn ); } else { this.stack.unshift( fn ); } return this; } Route.prototype.match = function match( path ) { const matches = this.regexp.exec( path ); if ( !matches ) return null; const keys = this.keys; const params = Object.assign({}, this.params); for( var idx = 1; idx &lt; matches.length; idx++ ) { params[ keys[ idx - 1 ] ] = matches[ idx ]; } return params; }; Route.prototype.process = function process( req, res, node, next ) { const stack = this.stack; ;(function run( idx ) { const fn = stack[ idx]; try { fn(req, res, node, (err, out) =&gt; { if ( err ) return next( err ); if( idx === stack.length -1 ) return next(); run(++idx); }); } catch ( err ){ err.statusCode = err.statusCode || 500; return next( err ); } })(0); } module.exports = Route; /** * A route middleware function * @typedef {Function} Middleware * @param {http.IncomingMessage} req The incomming request * @param {http.ServerResponse} res The response object to be sent * @param {module:skyring/lib/server/node} node The internal Ring Node instance * @param {Function} next The continuation callback to call when the middleware is finished **/ × Search results Close "},"lib_server_router.js.html":{"id":"lib_server_router.js.html","title":"Source: lib/server/router.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/server/router.js /*jshint laxcomma: true, smarttabs: true, node: true, esnext: true*/ 'use strict'; /** * Simple router class for directing requests * @module skyring/lib/server/router * @author Eric Satterwhite * @since 1.0.0 * @requires skyring/lib/server/route * @requires skyring/lib/server/request * @requires skyring/lib/server/response */ const Route = require('./route') , Request = require('./request') , Response = require('./response') ; /** * @constructor * @alias module:skyring/lib/server/router * @param {module:skyring/lib/server/node} node The node linked to the application hashring to pass with each request * @param {module:skyring/lib/timers} timers A timer instance associated with the application hashring to pass with each request * @example var x = new Router(node, timers) router.handle(req, res) */ function Router( node, timers ) { this.routes = new Map(); this.route_options = new Map(); this.node = node; this.timers = timers }; /** * Adds a new get handler to the router a new get handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.get = function get( path, fn ) { this.route( path, 'GET', fn ); }; /** * Adds a new put handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.put = function put( path, fn ) { this.route( path, 'PUT', fn); }; /** * Adds a new post handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.post = function post( path, fn ) { this.route( path, 'POST', fn); }; /** * Adds a new patch handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.patch = function patch( path, fn ) { this.route( path, 'PATCH', fn); }; /** * Adds a new delete handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.delete = function( path, fn ) { this.route( path, 'DELETE', fn ); }; /** * Adds a new opts handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.options = function options( path, fn ) { this.route( path, 'OPTIONS', fn ); }; /** * Adds a new route handler to the router * @param {String} path The url path to route on * @param {String} m handlerethod The http method to associate to the route * @param {Function} The handler function to call when the route is matched **/ Router.prototype.route = function route( path, method, fn ) { const _method = method.toUpperCase(); const map = this.routes.get(_method) || new Map(); if ( map.has( path ) ) { const route = map.get( path ); route.use( fn ); return route; } const route = new Route( path, _method); route.use( fn ); map.set( path, route ); this.routes.set( _method, map ); return route; }; /** * Entrypoint for an incoming request * Customer properties are attached to an `$` object on the request rather than the request * itself to avoid V8 deopts / perf penalties * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @example http.createServer((req, res) =&gt; { router.handle(req, res) }) **/ Router.prototype.handle = function handle( req, res ) { req.$ = new Request( req ); res.$ = new Response( res ); req.$.timers = this.timers; const path = req.$.path; const method = req.method.toUpperCase(); const map = this.routes.get( method ); if( map ) { let rte = map.get( path ); if ( rte ) { req.$.params = Object.create(null); return this.handleRoute( rte, req, res ); } for ( const route of map.values() ){ const params = route.match( path ); if ( params ) { req.$.params = params; return this.handleRoute( route, req, res ); } } } return notFound( req, res ); }; /** * Responsible for executing the middleware stack on the route ( including the end handler ) * @param {module:skyring/lib/server/route} route * @param {http.IncomingMessage} req * @param {http.ServerResponse} res **/ Router.prototype.handleRoute = function handleRoute( route, req, res ) { route.process(req, res, this.node, ( err ) =&gt; { if ( err ) return res.$.error( err ); if ( res.$.body ) return res.$.json( res.$.body ); return res.$.end(); }); }; function notFound( req, res ) { res.writeHead(404,{ 'Content-Type': 'application/json' }); res.end( JSON.stringify({message: 'Not Found' }) ); } module.exports = Router; × Search results Close "},"lib_timer.js.html":{"id":"lib_timer.js.html","title":"Source: lib/timer.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/timer.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true, unused: true*/ 'use strict'; /** * Manage Timers on a node * @module skyring/lib/timer * @author Eric Satterwhite * @since 3.0.0 * @requires debug * @requires skyring/lib/transports * @requires skyring/lib/nats * @requires skyring/lib/json */ const os = require('os') , crypto = require('crypto') , path = require('path') , levelup = require('levelup') , conf = require('keef') , transports = require('./transports') , nats = require('./nats') , json = require('./json') , debug = require('debug')('skyring:timer') , rebalance = require('debug')('skyring:rebalance') , store = require('debug')('skyring:store') , storage = Symbol('storage') , noop = () =&gt; {} ; /** * Node style callback * @typedef {Function} Nodeback * @property {?Error} [err] An error instance. If not null, the results should not be trusted * @property {Object} result The results of the function execution **/ /** * @constructor * @alias module:skyring/lib/timer * @param {Object} [options] * @param {Object} [options.nats] Nats connection information * @param {String[]} [options.nats.servers] A list of nats `host:port` to connect to * @param {Object} [options.storage] Storage config options for level db * @param {String[]} [options.storage.backend=memdown] a requireable module name, or absolute path to a leveldb compatible backend * `leveldown` and `memdown` are installed by default * @param {String} options.storage.path A directory path to a leveldb instance. One will be created if it doesn't already exist. * If the backend is memdown, this is optional and randomly generated per timer instance * @param {Function} [onReady=()=&gt;{}] A callback function to call after initial recovery has completed * If not specified, configuration values will be used **/ class Timer extends Map { constructor(options = {}, cb = () =&gt; {}) { super(); this.options = Object.assign({}, { nats: null , storage: null }, options); this._sid = null; this._bail = false; this.nats = nats.createClient( this.options.nats ); const store_opts = conf.get('storage'); const opts = Object.assign(store_opts, this.options.storage); store(opts) if (!opts.path) { if (opts.backend === 'memdown') { opts.path = path.join( os.tmpdir() , `skyring-${crypto.randomBytes(10).toString('hex')}` ); } else { const err = new Error('storage.path must be set with non memdown backends'); err.code = 'ENOSTORAGE'; throw err; } } debug('storage path', opts); this[storage] = levelup(opts.path, { valueEncoding: 'json' , db: require( opts.backend ) , cacheSize: opts.cache }); this[storage].once('ready', () =&gt; { debug('storage backend ready', conf.get('storage')); this.recover(cb); }); } /** * Sets a new time instance. If The timer has lapsed, it will be executed immediately * @method module:skyring/lib/timer#create * @param {String} id A unique Id of the time * @param {Object} body Configuration options for the timer instance * @param {Number} body.timeout Duration in milisecods to delay execution of the timer * @param {String} body.data The data to be assicated with the timer, when it is executed * @param {Number} [body.created=Date.now()] timestamp when the timer is created. if not set, will default to now * @param {Object} callback Options for the outbound transport for the timer when it executes * @param {String} callback.transport The transport type ( http, etc ) * @param {String} transport.method The method the transport should use when executing the timer * @param {String} transport.uri The target uri for the transport when the timer executes * @param {Nodeback} callback * @example const crypto = require('crypto') id = crypto.createHash('sha1') .update(crypto.randomBytes(10)) .digest('hex') const options = { timeout: 4000 , data: &quot;this is a payload&quot; , callback: { transport: 'http' , method: 'put , uri: 'http://api.domain.com/callback' } } timers.create(id, options, (err) =&gt; { if (err) throw err }) **/ create(id, body, cb) { const payload = body; const transport = transports[payload.callback.transport]; if ( this.has( id ) ) { const err = new Error( 'Key exists' ); err.code = 'EKEYEXISTS'; return setImmediate(cb, err); } const now = Date.now(); const created = payload.created || now; const elapsed = now - created; if( now &gt; created + payload.timeout ){ debug('executing stale timer'); setImmediate( transport , payload.callback.method , payload.callback.uri , payload.data , id , this ); return cb(null, id); } const data = { created: Date.now() , id: id , payload: payload , timer: null }; this[storage].put(id, data, (err) =&gt; { debug('setting timer', id); //TODO(esatterwhite): // what should happen if leveldb fails. if (err) console.error(err); data.timer = setTimeout( transport , payload.timeout - elapsed , payload.callback.method , payload.callback.uri , payload.data , id , this ).unref(); this.set( id, data ); cb(null, id); }); } /** * Cancels a specific timer * @method module:skyring/lib/timer#delete * @param {String} id The id of the timer to cancel * @param {Nodeback} callback Node style callback to execute **/ remove(id, cb) { this[storage].del(id, (err) =&gt; { if (err) return console.error('unable to purge %s', id, err); store('%s purged from storage', id, this.options.storage); }); const t = this.get(id); if( !t ) { const err = new Error('Not Found'); err.code = 'ENOENT'; return cb &amp;&amp; setImmediate(cb, err); } clearTimeout(t.timer); this.delete(id); debug('timer cleared', id); return cb &amp;&amp; setImmediate(cb); } rebalance(opts, node, cb) { const callback = cb || noop , size = this.size ; if( !size ) return; const records = this.values(); const run = ( obj ) =&gt; { if ( node.owns( obj.id ) ) return; clearTimeout( obj.timer ); this.delete( obj.id ); const data = Object.assign({}, obj.payload, { id: obj.id , created: obj.created }); rebalance( 'no longer the owner of %s', obj.id ); callback( data ); }; for( var record of records ) { run( record ); } } recover(cb) { const fn = (data) =&gt; { store('recover', data.key); const out = Object.assign({}, data.value.payload, { id: data.value.id , created: data.value.created }); this.create(data.key, out, debug); }; const stream = this[storage].createReadStream(); stream .on('data', fn) .once('close', function () { debug('recover stream close'); stream.removeListener('data', fn); cb &amp;&amp; cb(); }); } /** * Updates a timer inplace * @method module:skyring/lib/timer#update * @param {String} id A unique Id of the time * @param {Object} body Configuration options for the timer instance * @param {Number} body.timeout Duration in milisecods to delay execution of the timer * @param {String} body.data The data to be assicated with the timer, when it is executed * @param {Object} callback Options for the outbound transport for the timer when it executes * @param {String} callback.transport The transport type ( http, etc ) * @param {String} transport.method The method the transport should use when executing the timer * @param {String} transport.uri The target uri for the transport when the timer executes * @param {Nodeback} callback **/ update(id, body, cb){ this.remove(id, ( err ) =&gt; { if ( err ) return cb( err ); debug( 'updating timer', id ); this.create( id, body, cb ); }); } /** * Triggers timers to be rebalanced with in the ring before sutdown, and cancels all locally pending timers * @method module:skyring/lib/timer#shutdown * @param {Nodeback} callback Node style callback to execute when the function is complete **/ shutdown(cb) { const size = this.size; const client = this.nats; this[storage].close(); if( !size ) return this.nats.quit(cb); let sent = 0; let acks = 0; client.unsubscribe( this._sid ); this._sid = null; const run = ( obj ) =&gt; { clearTimeout( obj.timer ); const data = Object.assign({}, obj.payload, { id: obj.id , created: obj.created , count: ++sent }); this.nats.publish('skyring', JSON.stringify( data ), () =&gt; { if( ++acks === size ) return setImmediate(this.nats.quit, cb); rebalance( '%s of %s processed', data.count, acks, data.id); }); }; for( var record of this.values() ) { run( record ); } this.clear(); } close(cb){ this[storage].close(cb); } /** * Starts an internal nats queue * @method module:skyring/lib/timer#watch * @param {String} key The key name in redis to use as a timer queue * @param {Nodeback} callback Node style callback to execute when the function has finished execution **/ watch( key, cb ){ if( this._bail ) return; const opts = { queue: key }; this._sid = this.nats.subscribe('skyring', opts, ( data ) =&gt; { if( this._bail ) return; const value = json.parse( data ); cb( value.error, value.value ); }); return this._sid; } } module.exports = Timer; × Search results Close "},"lib_transports_index.js.html":{"id":"lib_transports_index.js.html","title":"Source: lib/transports/index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/transports/index.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true*/ 'use strict'; /** * Available tranports * @module skyring/lib/transports * @author Eric Satterwhite * @since 1.0.0 * @requires skyring/lib/transports/http */ const callback = require('./callback') /** * DESCRIPTION * @memberof module:skyring/lib/transports * @property {Object} http The HTTP transport **/ exports.http = require('./http'); Object.defineProperty(exports, 'callback',{ enumerable: false , configurable: false , get: function(){ switch(process.env.NODE_ENV){ case 'production': case 'prod': const err = new Error('callback transport is for testing only') err.name = 'TransportError'; err.code = 'ENOTRANSPORT'; throw err; default: return callback; } } }); × Search results Close "},"lib_transports_http.js.html":{"id":"lib_transports_http.js.html","title":"Source: lib/transports/http.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/transports/http.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true*/ 'use strict'; /** * The Http transport backend * @module skyring/lib/transports/http * @author Eric Satterwhite * @since 1.0.0 * @requires http * @requires request * @requires debug * @requires skyring/lib/timer */ const STATUS_CODES = require('http').STATUS_CODES , method_exp = /^(post|put|patch|delete|get|options|head)$/i , request = require('request') , debug = require('debug')('skyring:transport:http') ; /** * Dispatches an http request * @function * @alias module:skyring/lib/transports/http * @param {String} method The http method to use when dispatching the request * @param {String} url the url to target when dispatching * @param {String} payload The data payload to include in the request * @param {String} id The id of the timer being executed * @param {module:skyring/lib/timer} cache A timer cache instance to delete from after execution **/ module.exports = function makeRequest( method, url, payload, id, cache) { const isJSON = typeof payload === 'object' , _method = method.toLowerCase() , options = { body: payload || &quot;&quot; , json: isJSON }; if( method_exp.test(method) &amp;&amp; typeof request[_method] !== 'function' ) { const t = cache.get(id) t &amp;&amp; clearTimeout(t.timer) cache.remove(id) debug('unable to execute http transport', method, id) return } debug('executing http transport %s', id, method); request[_method](url, options, (err, res, body) =&gt; { if(err){ debug('timer err', err); return cache.remove(id); } if(res.statusCode &gt; 299 ){ debug('timer fail', err); const err = new Error(STATUS_CODES[res.statusCode]) err.code = res.statusCode = res.statusCode; console.error(err, body) return cache.remove(id); } debug('timer sucess'); return cache.remove(id); }); }; × Search results Close "},"lib_transports_callback.js.html":{"id":"lib_transports_callback.js.html","title":"Source: lib/transports/callback.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Source: lib/transports/callback.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true*/ 'use strict'; /** * A noop function transport for testing * @module skyring/lib/transports/timer * @author Eric Satterwhite * @since 1.0.4 */ module.exports = function callback( method, url, payload, id, cache ){ setImmediate(payload[method], url, id) } × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Modules Classes module:skyring/lib/server module:skyring/lib/server/node module:skyring/lib/server/route module:skyring/lib/server/router module:skyring/lib/timer × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module Docs API Docs SkyringA distributed reliable timer service providing similar functionality to using setTimeout. Skyring servers are clustered into a hashring using consistent hashing to partition timers to specific nodes in the ring. Skyring exposes a simple HTTP API That allows to you create and cancel timers. Timer execution comes in to the form of an HTTP webhook ( more transports to come ) Architechture Overview Installnpm install -s skyringRun A Local ClusterStart a nats instanceDownload the nats binary and start it using the defaults $ gnats -D -VTo verify that it is working, you can telnet directly to the server and ping it. $ telnet localhost 42222 &gt; ping PONGSkyring CLIIf you intend to run skyring as is, it may be preferable to use the included binary over cloning the project. npm install -g skyring DEBUG=skyring:* skyring run -p 3000 -s localhost:3456 -s localhost:3455Clone SkyringAlternatively to the CLI, you can clone and install the project manually $ git clone https://github.com/esatterwhite/skyring.git $ cd skyring $ npm install $ DEBUG=* node index.jsThe default settings expect a minimum of 2 servers on port 3455 and 3456 respectively. Start each server in a different terminal session # Seed node 1 $ DEBUG=skyring:* node index.js --channel:port=3455 -p 3000# Seed node 2 $ DEBUG=skyring:* node index.js --channel:port=3456 -p 3001If all goes well you should see a message like this skyring:ring ring bootstraped [ '127.0.0.1:3455', '127.0.0.1:3456' ] +1msThats it, you have 2 instances running w/ HTTP servers running on ports 3000 and 3001 Run via Docker ComposeThe Easiest way to run a small cluster is to use the included compose files. It is also a good way to see how to quickly configure a cluster Install Docker Compose $ npm startThat is it! You have a 5 node Skyring cluster with a 3 node nats cluster behind an nginx proxy listening on port 8080 Timer APIA request can be issued to any active node in the cluster. If that node is not responsible for the timer in question, it will forward the request directly to the node that is keeping network latency to a minimum. This makes Skyring very suitable for high performance, stateless, and distributed environments. The minimum recommended cluster size is 3 nodes, 2 of which being seed or bootstrapping nodes. A cluster of this size can average between 2K - 5K requests per second. Create a timerPOST /timerRequest curl -i -XPOST http://localhost:8080/timer -d '{ &quot;timout&quot;: 6000, &quot;data&quot; : &quot;{\\&quot;foo\\&quot;:\\&quot;bar\\&quot;}&quot;, &quot;callback&quot;: { &quot;transport&quot;: &quot;http&quot;, &quot;method&quot;: &quot;post&quot;, &quot;uri&quot;: &quot;http://api.someservice.com/hook/timout&quot; } }'Response Headers For performance considerations, a body is not included in responses. Rather, HTTP headers are used to relay information about timer status. In the case of a Create request, the uri to the timer instance is returned in the Location header. HTTP/1.1 201 CREATED location: /timer/4adb026b-6ef3-44a8-af16-4d6be0343ecf Date: Fri, 23 Dec 2016 00:19:13 GMT Connection: keep-alive Content-Length: 0Cancel A TimerDELETE /timer/:idRequest curl -i -XDELETE http://localhost:8080/timer/4adb026b-6ef3-44a8-af16-4d6be0343ecfResponse Headers HTTP/1.1 202 Accepted Date: Fri, 23 Dec 2016 00:22:12 GMT Connection: keep-alive Content-Length: 0Crash RecoveryEach Skyring node uses an internal levelup instance to record timers that it owns. When a node starts, it will check the configured database for any existing timers, and will immediately load them back into memory. By default, the memdown backend is used, and wil not persists between starts. To enable full persistence and recovery, you must configure skyring to use a persistent backend for levelup. Leveldown is installed by default. skyring run --storage:backend=leveldown --storage:path='/var/data/skyring' × Search results Close "},"module-keef.html":{"id":"module-keef.html","title":"Module: keef","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: keef The conf package reads configurations options in an overriding fashion from a number of sources. In order of importance: System level overrides Command line arguments Environment variables A configuration file(s) System specified defaults OverridesOverrides can not be overriden or changed at any point in time. The are defined in conf/lib/overrides.js and should be reserved for static run time properties. Conf serves as a central place to get that information. For example, the full path to the packages directory is resolved at run time and loaded in to the conf loader. It won't / can't change during run time, but may change in the future. By getting the information from conf, application logic does not need to change between restarts or releases. If overrides need to be change or added the overrides.js file must be changed Command Line ArgumentsCommand line arguments are the highest level of maliable values. The can be used to set specific and nested values in the configuration JSON document but using a : spearator between keys. For example, using the flag: --foo:bar=1, would create an object like { &quot;foo&quot;:{ &quot;bar&quot;: 1 } }Environment VariablesEnvironment variables work much the same as command line arguments. However, most bash implenetations don't read :'s very well, so the double underscore ( __ ) is used in its place foo__bar=1 npm start { &quot;foo&quot;:{ &quot;bar&quot;: 1 } }Conf OptionsThe conf option can be set to read specific configuration from a file(s). The value should be a full path. If the path points to a directory, the conf loader will read all json files, sort them and load their values in an overriding order. Sorting is done in a descending, lexigraphical order. └── conf ├── 20-keef.json ├── 10-keef.json └── 30-keef.jsonGiven the above directory of conf files, the server can be configured by pointing the conf arguments at the directory node server --conf=$HOME/confThe configruation would be read in the following priority 10-keef.json &lt; 20-keef.json &lt; 30-keef.json where 20 overrides 10, and 30 overrides 20. Static File DefaultsTo Simplify configuration for deployments, keef will look for configuration files in fixed locations eliminating the need for run time configuration. File Locations are as follows: a file in the rooot of your project with the name &lt;package.name&gt;.NODE_ENV.json For example, if the name attribute in your package.json is foobar, and the environment var NODE_ENV is set as production, the file look up is foobar.production.json. If NODE_ENV is not set, it would be foobar.development.json A json file named after your project name in the root of your project - foobar.json A json file named after your project in a .config directory in the current users home directory - .config/foobar.json A json file named after your project in the /etc directory - `/etc/foobar.json ETCD2 ClustersFor distributed deployments, An etcd2 cluster may be used for configuration purposes. To enable etcd2 configuration loading, 2 environment variables should be set: etcd__hosts - A comma separated list of host:port addresses - etcd1.domain.com:4001,etcd2.domain.com:4001. etcd__namespace - a keyspace to keep data separate from everything else. Any configuration that is stored as object, we be translated into etcd directories automatically keef.set('a:b:c', 1) // Object data { &quot;a&quot;: { &quot;b&quot;: { &quot;c&quot;: 1 } } } // etc data /a/b/c 1System defaultsdefaults are what they sound like. Sane defaults for values that are needed to get the application running. They are located in the Defaults module and are used only as fallback values. Option ShorthandsTop level options can be aliased. Short hand aliases can be found and defined in the Shorthands module of keef Flag Shorthand Description PORT p Specifies the port the server will bind to logger l specify the type(s) of logging transports for the server to use the following invocations are treated the same node server --PORT=3001 --logger=stdout --logger=filePORT=3001 logger=stdout nodeserver -l filenode server -p 3001 -l stdout -l file Since: 0.1.0 Author: Eric Satterwhite Source: node_modules/keef/index.js Requires module:nconf module:path module:os module:debug module:fs module:keef/lib/shorthands module:keef/lib/defaults module:keef/lib/overrides × Search results Close "},"module-skyring.html":{"id":"module-skyring.html","title":"Module: skyring","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring Distributed timers as a service Exports a default server instance. If executed directly, the server will be started automoaticall and configured to auto rebalance on SIGINT and SIGTERM Since: 1.0.0 Author: Eric Satterwhite Source: index.js Requires module:http module:debug module:keef module:skyring/lib/server × Search results Close "},"module-skyring_conf.html":{"id":"module-skyring_conf.html","title":"Module: skyring/conf","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/conf Configuration options for skyring. See module:keef on ways to pass configuration Since: 1.0.0 Author: Eric Satterwhite Source: conf/index.js Members &lt;static&gt; seeds Properties: Name Type Argument Default Description seeds String | Array.&lt;String&gt; &lt;optional&gt; 127.0.0.1:3455,127.0.0.1:3456 A list of seed nodes to use for bootstrapping a ring cluster channel Object Properties Name Type Argument Default Description host String &lt;optional&gt; 127.0.0.1 hostname or ip addres for tchannel to listen on port Number &lt;optional&gt; 3455 Port number for tchannel to bind to PORT Number &lt;optional&gt; 3000 The port number for the http API server to bind to nats Object Nats queue specific configuration Properties Name Type Argument Default Description hosts String | Array.&lt;String&gt; &lt;optional&gt; 127.0.0.1:4222 host:port of instances of a nats cluster. One is usually enough. Source: conf/index.js × Search results Close "},"module-skyring_lib_json.html":{"id":"module-skyring_lib_json.html","title":"Module: skyring/lib/json","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/json JSON helpers (require(&quot;skyring/lib/json&quot;))(json) Wrpper around try/catch of JSON parsing Parameters: Name Type Description json String A JSON string to parse Source: lib/json.js Returns: Type module:skyring/lib/json~Result Type Definitions Result Composite JSON ojbect Type: Object Properties: Name Type Argument Default Description error Error &lt;optional&gt; &lt;nullable&gt; null An error if json parsing faile value Object the result of Json parsing Source: lib/json.js × Search results Close "},"module-skyring_lib_nats.html":{"id":"module-skyring_lib_nats.html","title":"Module: skyring/lib/nats","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/nats Small wrapper around nats for quickly connecting / disconnecting Since: 1.0.0 Author: Eric Satterwhite Source: lib/nats.js Example const nats= require('skyring/lib/nats') const client = nats.createClient() client.publish('foobar', JSON.stringify({'foo':'bar'}), () =&gt; { nats.quit() }) Requires module:url module:nats module:keef module:debug Methods createClient( [options]) Creates a new nats client Parameters: Name Type Argument Description options Object &lt;optional&gt; nats client configuration Properties Name Type Argument Default Description hosts String &lt;optional&gt; localhost:4222 a comma separated list of addresses of nats hosts to connect to Source: lib/nats.js Returns: A nats client instance Type NatsClient Example nats.createClient({ hosts:'nats-1.domain.com:4222,nats-2.domain.com:4223,localhost:4222' }) × Search results Close "},"module-skyring_lib_server.html":{"id":"module-skyring_lib_server.html","title":"Module: skyring/lib/server","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/server Primary server instance for a skyring app. new (require(&quot;skyring/lib/server&quot;))( [options]) Extends: http.Server Parameters: Name Type Argument Default Description options Object &lt;optional&gt; Properties Name Type Argument Description node module:skyring/lib/server/node &lt;optional&gt; A customer node instance optiopns.node.host String &lt;optional&gt; host name for the node to listen on - 127.0.0.1 must be used for localhost ( not 0.0.0.0 ) options.node.port Number &lt;optional&gt; Port number for the node to listen on in the ring options.node.app String &lt;optional&gt; timers name of the active ring to join options.nats Object &lt;optional&gt; Properties Name Type Argument Description servers Array.&lt;String&gt; &lt;optional&gt; An array of nats host:port addresses to connect to Since: 1.0.0 Author: Eric Satterwhite Source: lib/server/index.js Examples // Use only configuration values var server = new Server().load().listen(5000) var server = new Server({ node :{ host: 172.17.0.9 , port: 8456 , app: 'payback' } , nats: { servers: ['nats1.domain.com:4222', 'nats2.domain.com:4222'] } }) server.load().listen(5000) // Use a custom node instance var node = new Node({ host: 172.17.0.9 , port: 8456 , app: 'payback' }) var server = new Server({ node }) server.load().listen(5000) Requires module:http module:debug module:skyring/lib/server/mock module:skyring/lib/server/node module:skyring/lib/server/router module:skyring/lib/timer Methods close(callback) Removes a server from the ring, closes the http server and redistributes any pending timers Parameters: Name Type Description callback function A callback to be called when the server is completely shut down Source: lib/server/index.js listen(port [, host] [, backlog] [, callback]) Joins the node to the configured ring and starts the http server Parameters: Name Type Argument Default Description port Number Port number to listen on host String &lt;optional&gt; localhost host or ip address to listen on backlog Number &lt;optional&gt; callback function &lt;optional&gt; Callback function to call when the server is running Source: lib/server/index.js Returns: Type module:skyring/lib/server load() loads application routes if not already loaded Source: lib/server/index.js Returns: Type module:skyring/lib/server × Search results Close "},"module-skyring_lib_server_mock.html":{"id":"module-skyring_lib_server_mock.html","title":"Module: skyring/lib/server/mock","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/server/mock Mock http request / response object for use when proxing requests through TChannel Since: 1.0.0 Author: Eric satterwhite Source: lib/server/mock.js Requires module:stream module:events module:url module:util module:http × Search results Close "},"module-skyring_lib_server_node.html":{"id":"module-skyring_lib_server_node.html","title":"Module: skyring/lib/server/node","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/server/node Represents a participant in the Hashring new (require(&quot;skyring/lib/server/node&quot;))( [host] [, port] [, name] [, app]) Parameters: Name Type Argument Default Description host String &lt;optional&gt; host name for the node to listen on - 127.0.0.1 must be used for localhost ( not 0.0.0.0) port Number &lt;optional&gt; Port number for the node to listen on in the ring name String &lt;optional&gt; 'ringpop' name of the active ring to join app String &lt;optional&gt; timers app name of the active ring Source: lib/server/node.js Requires module:events module:dns module:ringpop module:tchannel module:debug module:keef Methods close(A) Removes itself from the ring and closes and connections Parameters: Name Type Description A function callback function to call when the ring is closed Source: lib/server/node.js handle(handler) Adds a request handler to the active ringpop instance Parameters: Name Type Description handler function A request handler for incoming requests from the ring Source: lib/server/node.js handleOrProxy(Key, req, res) Determines if this instance is responsible for a specific key. proxies the request if it is not Parameters: Name Type Description Key String The key to use to do a node lookup in the ring req http.IncomingMessage an http request object res http.ServerResponse an http response object Source: lib/server/node.js Returns: Type Boolean Example const handle = node.handleOrProxy('foobar', req, res) if (!handle) return; // deal with request join( [seeds], callback) Does the work of configuring tchannel and joining itself into a ringpop ring Parameters: Name Type Argument Description seeds Array.&lt;String&gt; &lt;optional&gt; An array of node addresses to use as boot strapping nodes callback function Function to call when the node has completed the bootstrap process Source: lib/server/node.js Example node.join(['node-1:5555', '172.10.0.4:4563'], (err) =&gt; { if (err) throw err }) leave(callback) Removes itself from the active ring and destroys existing connections Parameters: Name Type Description callback function Callback function to call when the eviction process is complete Source: lib/server/node.js lookup(key) Lookup the address of the server responsible for a given key Parameters: Name Type Description key String The key to look up Source: lib/server/node.js Returns: A server address Type String owns(key) Determines if this node is responsible for a specific key Parameters: Name Type Description key String The key to use Source: lib/server/node.js Returns: Type Boolean × Search results Close "},"module-skyring_lib_server_request.html":{"id":"module-skyring_lib_server_request.html","title":"Module: skyring/lib/server/request","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/server/request Simple wrapper around the http request object to avoid deopts Since: 1.0.0 Author: Eric Satterwhite Source: lib/server/request.js Requires module:url × Search results Close "},"module-skyring_lib_server_response.html":{"id":"module-skyring_lib_server_response.html","title":"Module: skyring/lib/server/response","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/server/response Simple wrapper around the http response object to avoid deopts Since: 1.0.0 Author: Eric Satterwhite Source: lib/server/response.js Requires module:debug × Search results Close "},"module-skyring_lib_server_route.html":{"id":"module-skyring_lib_server_route.html","title":"Module: skyring/lib/server/route","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/server/route represents the middleware stack for a url / method combination new (require(&quot;skyring/lib/server/route&quot;))(path, method) Parameters: Name Type Description path String the url pattern to match method String The http method to respect Source: lib/server/route.js Example var rte = new Route('/foo/:id', 'POST') rte.use((req, res, node, next) =&gt; { if(req.method === 'DELETE') { const err = new Error('Not Implemented') err.statusCode = 501 next(err) } }) Requires module:path-to-regexp Methods before(fn) Adds a middleware function to the beginning of the internal route stack Parameters: Name Type Description fn module:skyring/lib/server/route~Middleware a the middelware function to add Source: lib/server/route.js use(fn) Adds a middleware function to the end of the internal route stack Parameters: Name Type Description fn module:skyring/lib/server/route~Middleware a the middelware function to add Source: lib/server/route.js Type Definitions Middleware(req, res, node, next) A route middleware function Parameters: Name Type Description req http.IncomingMessage The incomming request res http.ServerResponse The response object to be sent node module:skyring/lib/server/node The internal Ring Node instance next function The continuation callback to call when the middleware is finished Source: lib/server/route.js × Search results Close "},"module-skyring_lib_server_router.html":{"id":"module-skyring_lib_server_router.html","title":"Module: skyring/lib/server/router","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/server/router Simple router class for directing requests new (require(&quot;skyring/lib/server/router&quot;))(node, timers) Parameters: Name Type Description node module:skyring/lib/server/node The node linked to the application hashring to pass with each request timers module:skyring/lib/timers A timer instance associated with the application hashring to pass with each request Source: lib/server/router.js Example var x = new Router(node, timers) router.handle(req, res) Requires module:skyring/lib/server/route module:skyring/lib/server/request module:skyring/lib/server/response Methods delete(path, handler) Adds a new delete handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js get(path, handler) Adds a new get handler to the router a new get handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js handle(req, res) Entrypoint for an incoming request Customer properties are attached to an $ object on the request rather than the request itself to avoid V8 deopts / perf penalties Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse Source: lib/server/router.js Example http.createServer((req, res) =&gt; { router.handle(req, res) }) handleRoute(route, req, res) Responsible for executing the middleware stack on the route ( including the end handler ) Parameters: Name Type Description route module:skyring/lib/server/route req http.IncomingMessage res http.ServerResponse Source: lib/server/router.js options(path, handler) Adds a new opts handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js patch(path, handler) Adds a new patch handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js post(path, handler) Adds a new post handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js put(path, handler) Adds a new put handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js route(path, m, The) Adds a new route handler to the router Parameters: Name Type Description path String The url path to route on m String handlerethod The http method to associate to the route The function handler function to call when the route is matched Source: lib/server/router.js × Search results Close "},"module-skyring_lib_timer.html":{"id":"module-skyring_lib_timer.html","title":"Module: skyring/lib/timer","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/timer Manage Timers on a node new (require(&quot;skyring/lib/timer&quot;))( [options] [, onReady]) Parameters: Name Type Argument Default Description options Object &lt;optional&gt; Properties Name Type Argument Description nats Object &lt;optional&gt; Nats connection information Properties Name Type Argument Description servers Array.&lt;String&gt; &lt;optional&gt; A list of nats host:port to connect to storage Object &lt;optional&gt; Storage config options for level db Properties Name Type Argument Default Description backend Array.&lt;String&gt; &lt;optional&gt; memdown a requireable module name, or absolute path to a leveldb compatible backend leveldown and memdown are installed by default path String A directory path to a leveldb instance. One will be created if it doesn't already exist. If the backend is memdown, this is optional and randomly generated per timer instance onReady function &lt;optional&gt; ()=&gt;{} A callback function to call after initial recovery has completed If not specified, configuration values will be used Source: lib/timer.js Requires module:debug module:skyring/lib/transports module:skyring/lib/nats module:skyring/lib/json Methods create(id, body, callback, callback) Sets a new time instance. If The timer has lapsed, it will be executed immediately Parameters: Name Type Description id String A unique Id of the time body Object Configuration options for the timer instance Properties Name Type Argument Default Description timeout Number Duration in milisecods to delay execution of the timer data String The data to be assicated with the timer, when it is executed created Number &lt;optional&gt; Date.now() timestamp when the timer is created. if not set, will default to now callback Object Options for the outbound transport for the timer when it executes Properties Name Type Description transport String The transport type ( http, etc ) transport.method String The method the transport should use when executing the timer transport.uri String The target uri for the transport when the timer executes callback Nodeback Source: lib/timer.js Example const crypto = require('crypto') id = crypto.createHash('sha1') .update(crypto.randomBytes(10)) .digest('hex') const options = { timeout: 4000 , data: &quot;this is a payload&quot; , callback: { transport: 'http' , method: 'put , uri: 'http://api.domain.com/callback' } } timers.create(id, options, (err) =&gt; { if (err) throw err }) delete(id, callback) Cancels a specific timer Parameters: Name Type Description id String The id of the timer to cancel callback Nodeback Node style callback to execute Source: lib/timer.js shutdown(callback) Triggers timers to be rebalanced with in the ring before sutdown, and cancels all locally pending timers Parameters: Name Type Description callback Nodeback Node style callback to execute when the function is complete Source: lib/timer.js update(id, body, callback, callback) Updates a timer inplace Parameters: Name Type Description id String A unique Id of the time body Object Configuration options for the timer instance Properties Name Type Description timeout Number Duration in milisecods to delay execution of the timer data String The data to be assicated with the timer, when it is executed callback Object Options for the outbound transport for the timer when it executes Properties Name Type Description transport String The transport type ( http, etc ) transport.method String The method the transport should use when executing the timer transport.uri String The target uri for the transport when the timer executes callback Nodeback Source: lib/timer.js watch(key, callback) Starts an internal nats queue Parameters: Name Type Description key String The key name in redis to use as a timer queue callback Nodeback Node style callback to execute when the function has finished execution Source: lib/timer.js Type Definitions Nodeback() Node style callback Properties: Name Type Argument Description err Error &lt;optional&gt; &lt;nullable&gt; An error instance. If not null, the results should not be trusted result Object The results of the function execution Source: lib/timer.js × Search results Close "},"module-skyring_lib_transports.html":{"id":"module-skyring_lib_transports.html","title":"Module: skyring/lib/transports","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/transports Available tranports Since: 1.0.0 Author: Eric Satterwhite Source: lib/transports/index.js Requires module:skyring/lib/transports/http Members &lt;static&gt; exports.http DESCRIPTION Properties: Name Type Description http Object The HTTP transport Source: lib/transports/index.js × Search results Close "},"module-skyring_lib_transports_http.html":{"id":"module-skyring_lib_transports_http.html","title":"Module: skyring/lib/transports/http","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/transports/http The Http transport backend (require(&quot;skyring/lib/transports/http&quot;))(method, url, payload, id, cache) Dispatches an http request Parameters: Name Type Description method String The http method to use when dispatching the request url String the url to target when dispatching payload String The data payload to include in the request id String The id of the timer being executed cache module:skyring/lib/timer A timer cache instance to delete from after execution Source: lib/transports/http.js Requires module:http module:request module:debug module:skyring/lib/timer × Search results Close "},"module-skyring_lib_transports_timer.html":{"id":"module-skyring_lib_transports_timer.html","title":"Module: skyring/lib/transports/timer","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/serverskyring/lib/server/mockskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Module: skyring/lib/transports/timer A noop function transport for testing Since: 1.0.4 Author: Eric Satterwhite Source: lib/transports/callback.js × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
